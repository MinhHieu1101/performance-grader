This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
package.json
server.js
src/config/knexfile.js
src/config/knexInstance.js
src/controllers/authController.js
src/middleware/authenMiddleware.js
src/middleware/errorMiddleware.js
src/routes/authRoutes.js
src/utils/checkExistence.js
src/utils/generateTokens.js
src/utils/hashPassword.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Node modules
node_modules/

# Logs
logs
*.log
npm-debug.log*

# Environment variables
# .env

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Coverage directory used by tools like jest
coverage/

# nyc test coverage
.nyc_output/

# IDEs and editors
.idea/
.vscode/
*.sublime-project
*.sublime-workspace

cucumber_report.html
cucumber_report.json
</file>

<file path="package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "license": "ISC",
  "author": "",
  "type": "commonjs",
  "main": "server.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "nodemon server.js"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  },
  "dependencies": {
    "axios": "^1.9.0",
    "bcryptjs": "^3.0.2",
    "chalk": "^5.4.1",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "cross-env": "^7.0.3",
    "dotenv": "^16.5.0",
    "express": "^5.1.0",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "knex": "^3.1.0",
    "morgan": "^1.10.0",
    "pg": "^8.16.0",
    "pg-hstore": "^2.3.4"
  }
}
</file>

<file path="server.js">
import express from "express";
import cookieParser from "cookie-parser";
import cors from "cors";
import morgan from "morgan";
import chalk from "chalk";
import authRoutes from "./src/routes/authRoutes.js";
import errorHandler from "./src/middleware/errorMiddleware.js";
import dotenv from "dotenv";
dotenv.config();

const port = process.env.PORT || 5000;
const host = process.env.HOST || "localhost";

const allowedOrigins = ["http://localhost:5173"];

const corsOptions = {
  origin: allowedOrigins,
  credentials: true,
};

const app = express();

if (process.env.NODE_ENV !== "production") {
  app.use(morgan("dev"));
}

app.use(cors(corsOptions));
app.use(express.json());
app.use(express.urlencoded({ extended: true })); // parse URL-encoded bodies
app.use(cookieParser());

app.use("/auth", authRoutes);

app.listen(port, host, () => {
  console.log(
    `${chalk.cyan("Backend")} running in ${chalk.yellow(
      process.env.NODE_ENV
    )} environment and ready at http://${chalk.green(host)}:${chalk.green(
      port
    )}`
  );
});

app.use(errorHandler);
</file>

<file path="src/config/knexfile.js">
import dotenv from "dotenv";
dotenv.config();

export default {
  development: {
    client: "pg",
    connection: {
      host: process.env.DB_HOST,
      user: process.env.DB_USER,
      password: process.env.DB_PASS,
      database: process.env.DB_NAME,
    },
    pool: { min: 0, max: 5 }, // number of connection in pool
    migrations: {
      tableName: "knex_migrations",
      directory: "./migrations",
      extension: "js",
    },
  },

  production: {
    client: "pg",
    connection: process.env.DB_URL,
    pool: { min: 0, max: 5 },
    migrations: {
      tableName: "knex_migrations",
      directory: "./migrations",
      extension: "js",
    },
  },
};
</file>

<file path="src/config/knexInstance.js">
import pkg from "knex";
import config from "./knexfile.js";
import dotenv from "dotenv";
dotenv.config();

const { knex } = pkg;

const knexInstance = knex(config[process.env.NODE_ENV]);

export default knexInstance;
</file>

<file path="src/controllers/authController.js">
import db from "../config/knexInstance.js";
import bcrypt from "bcryptjs";

const registerUser = async (req, res, next) => {
  const { name, email, password } = req.body;

  try {
    const userExists = await User.findOne({ email });
    if (userExists) {
      res.status(409); // conflict
      throw new Error("User already exists");
    }

    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    const user = await User.create({
      name,
      email,
      password: hashedPassword,
    });

    return res.status(201).json({
      _id: user.id,
      name: user.name,
      email: user.email,
    });
  } catch (err) {
    next(err);
  }
};

const loginUser = async (req, res, next) => {
  const { email, password } = req.body;

  try {
    const user = await User.findOne({ email });
    if (!user) {
      res.status(400);
      throw new Error("No account found with this email");
    }

    const refreshToken = generateRefreshToken(user._id);
    const accessToken = generateAccessToken(user._id);
    if (user && (await bcrypt.compare(password, user.password))) {
      res.cookie("refreshToken", refreshToken, {
        httpOnly: true,
        sameSite: "Strict",
        secure: process.env.NODE_ENV === "production", // only secure in production
        maxAge: 24 * 60 * 60 * 1000, // 1d
        /* maxAge: 15 * 60 * 1000, // 15 minutes */
      });
      res.status(200).json({
        id: user.id,
        name: user.name,
        email: user.email,
        accessToken: accessToken,
        refreshToken: refreshToken,
      });
    } else {
      res.status(400);
      throw new Error("Invalid credentials");
    }
  } catch (err) {
    next(err);
  }
};

const logoutUser = async (req, res) => {
  res.clearCookie("refreshToken", {
    httpOnly: true,
    sameSite: "Strict",
    secure: process.env.NODE_ENV === "production",
  });

  res.status(200).json({ message: "Logout successful" });
};

export { registerUser, loginUser, logoutUser };
</file>

<file path="src/middleware/authenMiddleware.js">
import jwt from "jsonwebtoken";
import db from "../config/knexInstance.js";
import { generateAccessToken } from "../utils/generateTokens.js";
import dotenv from "dotenv";
dotenv.config();

const protect = async (req, res, next) => {
  const authHeader = req.headers.authorization;
  let accessToken = authHeader?.startsWith("Bearer ")
    ? authHeader.split(" ")[1]
    : null;
  if (!accessToken) {
    const err = new Error("Not Authorized. Invalid access token.");
    err.status = 401;
    throw err;
  }

  try {
    const decodedAccess = jwt.verify(
      accessToken,
      process.env.ACCESS_TOKEN_SECRET
    );
    req.user = await db("Users")
      .select("userId", "username", "email", "role")
      .where("userId", decodedAccess.userId)
      .first();
    return next();
  } catch (err) {
    const refreshToken = req.cookies.refreshToken;
    if (!refreshToken) {
      const err = new Error("Refresh token missing. Please log in again.");
      err.status = 401;
      throw err;
    }

    try {
      const decodedRefresh = jwt.verify(
        refreshToken,
        process.env.REFRESH_TOKEN_SECRET
      );
      const newAccessToken = generateAccessToken(decodedRefresh.userId);
      res.setHeader("Authorization", `Bearer ${newAccessToken}`);
      req.user = await db("Users")
        .select("userId", "username", "email", "role")
        .where("userId", decodedRefresh.userId)
        .first();
      return next();
    } catch {
      const err = new Error("Refresh token expired. Please log in.");
      err.status = 403;
      throw err;
    }
  }
};

export default protect;
</file>

<file path="src/middleware/errorMiddleware.js">
const errorHandler = (err, req, res, next) => {
  const statusCode = err.status || res.status || 500;

  res.status(statusCode).json({
    success: false,
    status: statusCode,
    message: err.message || "Something went wrong",
    errors: err.messages || [],
    stack: process.env.NODE_ENV === "development" ? err.stack : {},
  });
};

export default errorHandler;
</file>

<file path="src/routes/authRoutes.js">
import express from "express";
const router = express.Router();

import {
  registerUser,
  loginUser,
  logoutUser,
} from "../controllers/authController.js";

router.post("/register", registerUser);

router.post("/login", loginUser);

router.post("/logout", logoutUser);

export default router;
</file>

<file path="src/utils/checkExistence.js">
export const checkExistence = async (db) => {
  // to do
};
</file>

<file path="src/utils/generateTokens.js">
import jwt from "jsonwebtoken";
import dotenv from "dotenv";
dotenv.config();

export const generateAccessToken = (userId) => {
  return jwt.sign({ userId }, process.env.ACCESS_TOKEN_SECRET, {
    expiresIn: "30m",
  });
};

export const generateRefreshToken = (userId) => {
  return jwt.sign({ userId }, process.env.REFRESH_TOKEN_SECRET, {
    expiresIn: "1d",
  });
};
</file>

<file path="src/utils/hashPassword.js">
import bcrypt from "bcryptjs";

export const hashPassword = async (pw) => {
  const salt = await bcrypt.genSalt(10);
  const hashedPassword = await bcrypt.hash(pw, salt);
  return hashedPassword;
};
</file>

</files>
